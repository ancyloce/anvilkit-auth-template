name: deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: Deployment environment
        required: true
        default: production
        type: choice
        options:
          - production
          - staging
      overwrite_env:
        description: Overwrite remote $DEPLOY_PATH/.env even if it already exists
        required: false
        default: false
        type: boolean
  push:
    branches:
      - main
    tags:
      - 'v*'

permissions:
  contents: read
  packages: write

concurrency:
  group: deploy-${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  APP_NAME: anvilkit-auth-template

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta_auth.outputs.version }}
      image_owner: ${{ steps.prep.outputs.owner_lc }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Diagnostic trigger context
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF: ${{ github.ref }}
          REF_NAME: ${{ github.ref_name }}
          REF_TYPE: ${{ github.ref_type }}
          SHA: ${{ github.sha }}
          ACTOR: ${{ github.actor }}
          INPUTS_JSON: ${{ toJson(github.event.inputs) }}
        run: |
          echo "event_name=${EVENT_NAME}"
          echo "ref=${REF}"
          echo "ref_name=${REF_NAME}"
          echo "ref_type=${REF_TYPE}"
          echo "sha=${SHA}"
          echo "actor=${ACTOR}"
          echo "inputs=${INPUTS_JSON}"

      - name: Prepare image owner
        id: prep
        run: echo "owner_lc=${GITHUB_REPOSITORY_OWNER,,}" >> "$GITHUB_OUTPUT"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate auth-api metadata
        id: meta_auth
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ steps.prep.outputs.owner_lc }}/${{ env.APP_NAME }}-auth-api
          tags: |
            type=ref,event=tag
            type=sha,prefix=sha-

      - name: Validate production compose config
        env:
          IMAGE_OWNER: ${{ steps.prep.outputs.owner_lc }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          cp .env.example .env
          docker compose --env-file .env.example -f deploy/docker-compose.prod.yml config > /dev/null
          rm -f .env

      - name: Build and push auth-api image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: services/auth-api/Dockerfile
          push: true
          tags: ${{ steps.meta_auth.outputs.tags }}
          labels: ${{ steps.meta_auth.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Generate admin-api metadata
        id: meta_admin
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ steps.prep.outputs.owner_lc }}/${{ env.APP_NAME }}-admin-api
          tags: |
            type=ref,event=tag
            type=sha,prefix=sha-

      - name: Build and push admin-api image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: services/admin-api/Dockerfile
          push: true
          tags: ${{ steps.meta_admin.outputs.tags }}
          labels: ${{ steps.meta_admin.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required deploy secrets
        env:
          DB_DSN: ${{ secrets.DB_DSN }}
          REDIS_ADDR: ${{ secrets.REDIS_ADDR }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          CORS_ALLOW_ORIGINS: ${{ secrets.CORS_ALLOW_ORIGINS }}
          DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          set -euo pipefail
          missing=()
          for name in DB_DSN REDIS_ADDR JWT_SECRET CORS_ALLOW_ORIGINS DEPLOY_SSH_KEY DEPLOY_HOST DEPLOY_USER DEPLOY_PATH; do
            if [[ -z "${!name:-}" ]]; then
              missing+=("$name")
            fi
          done

          if ((${#missing[@]} > 0)); then
            echo "::error::Missing required secrets for deploy environment: ${missing[*]}"
            echo "Please configure these secrets in GitHub Environment '${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}'."
            echo "Required app secrets: DB_DSN, REDIS_ADDR, JWT_SECRET, CORS_ALLOW_ORIGINS"
            echo "Required deploy secrets: DEPLOY_SSH_KEY, DEPLOY_HOST, DEPLOY_USER, DEPLOY_PATH (DEPLOY_PORT optional; defaults to 22)"
            exit 1
          fi

      - name: Configure SSH key
        run: |
          install -m 700 -d ~/.ssh
          printf '%s\n' '${{ secrets.DEPLOY_SSH_KEY }}' > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519

      - name: Prepare remote .env content
        env:
          DB_DSN: ${{ secrets.DB_DSN }}
          REDIS_ADDR: ${{ secrets.REDIS_ADDR }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          CORS_ALLOW_ORIGINS: ${{ secrets.CORS_ALLOW_ORIGINS }}
          ACCESS_TTL_MIN: ${{ secrets.ACCESS_TTL_MIN }}
          REFRESH_TTL_HOURS: ${{ secrets.REFRESH_TTL_HOURS }}
          CORS_ALLOW_CREDENTIALS: ${{ secrets.CORS_ALLOW_CREDENTIALS }}
          USE_INTERNAL_DEPS: ${{ vars.USE_INTERNAL_DEPS }}
        run: |
          set -euo pipefail
          : "${JWT_SECRET:?missing required secret JWT_SECRET}"
          : "${CORS_ALLOW_ORIGINS:?missing required secret CORS_ALLOW_ORIGINS}"

          deps="${USE_INTERNAL_DEPS:-true}"
          db_dsn="${DB_DSN:-postgres://postgres:postgres@pg:5432/auth?sslmode=disable}"
          redis_addr="${REDIS_ADDR:-redis:6379}"

          if [[ "$db_dsn" == *"@127.0.0.1:"* || "$db_dsn" == *"@localhost:"* ]]; then
            if [[ "$deps" == "true" ]]; then
              db_dsn="postgres://postgres:postgres@pg:5432/auth?sslmode=disable"
              echo "DB_DSN points to localhost/127.0.0.1; overriding to internal compose service host pg:5432."
            else
              echo "DB_DSN points to localhost/127.0.0.1, which is invalid for containerized deploy with USE_INTERNAL_DEPS=false." >&2
              echo "Set DB_DSN to a reachable external DB host/IP (not localhost)." >&2
              exit 1
            fi
          fi

          access_ttl="${ACCESS_TTL_MIN:-15}"
          refresh_ttl="${REFRESH_TTL_HOURS:-168}"
          cors_credentials="${CORS_ALLOW_CREDENTIALS:-false}"

          cat > .deploy.env <<EOF_ENV
          DB_DSN=${db_dsn}
          REDIS_ADDR=${redis_addr}
          JWT_SECRET=${JWT_SECRET}
          CORS_ALLOW_ORIGINS=${CORS_ALLOW_ORIGINS}
          ACCESS_TTL_MIN=${access_ttl}
          REFRESH_TTL_HOURS=${refresh_ttl}
          CORS_ALLOW_CREDENTIALS=${cors_credentials}
          EOF_ENV
          chmod 600 .deploy.env

      - name: Ensure remote .env exists (or overwrite)
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          OVERWRITE_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.overwrite_env || 'false' }}
        run: |
          set -euo pipefail
          port="${DEPLOY_PORT:-22}"

          ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
            "mkdir -p '$DEPLOY_PATH'"

          if [[ "${OVERWRITE_ENV}" == "true" ]]; then
            scp -P "$port" -o StrictHostKeyChecking=accept-new .deploy.env \
              "$DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH/.env"
            ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
              "chmod 600 '$DEPLOY_PATH/.env'"
          else
            if ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
              "test -f '$DEPLOY_PATH/.env'"; then
              echo "Remote .env already exists; keeping existing file."
            else
              scp -P "$port" -o StrictHostKeyChecking=accept-new .deploy.env \
                "$DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH/.env"
              ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
                "chmod 600 '$DEPLOY_PATH/.env'"
            fi
          fi

      - name: Upload deployment assets
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          port="${DEPLOY_PORT:-22}"
          ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
            "mkdir -p '$DEPLOY_PATH/deploy' '$DEPLOY_PATH/scripts' '$DEPLOY_PATH/migrations'"

          scp -P "$port" -o StrictHostKeyChecking=accept-new deploy/docker-compose.prod.yml \
            "$DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH/deploy/docker-compose.prod.yml"
          scp -P "$port" -o StrictHostKeyChecking=accept-new scripts/remote_deploy.sh \
            "$DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH/scripts/remote_deploy.sh"
          scp -P "$port" -o StrictHostKeyChecking=accept-new services/auth-api/migrations/001_init.sql \
            "$DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH/migrations/001_init.sql"

      - name: Run remote deployment
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          IMAGE_TAG: ${{ needs.build.outputs.image_tag }}
          IMAGE_OWNER: ${{ needs.build.outputs.image_owner }}
          USE_INTERNAL_DEPS: ${{ vars.USE_INTERNAL_DEPS }}
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
        run: |
          set -euo pipefail
          : "${GHCR_USERNAME:?missing required secret GHCR_USERNAME}"
          : "${GHCR_TOKEN:?missing required secret GHCR_TOKEN}"

          port="${DEPLOY_PORT:-22}"
          deps="${USE_INTERNAL_DEPS:-true}"
          ghcr_username_escaped=$(printf '%q' "$GHCR_USERNAME")
          ghcr_token_escaped=$(printf '%q' "$GHCR_TOKEN")
          ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
            "chmod +x '$DEPLOY_PATH/scripts/remote_deploy.sh' && \
             GHCR_USERNAME=$ghcr_username_escaped GHCR_TOKEN=$ghcr_token_escaped \
             '$DEPLOY_PATH/scripts/remote_deploy.sh' '$DEPLOY_PATH' '$IMAGE_TAG' '$IMAGE_OWNER' '$deps'"

      - name: Cleanup local deploy env artifact
        if: always()
        run: rm -f .deploy.env
