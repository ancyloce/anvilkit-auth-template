name: deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: Deployment environment
        required: true
        default: production
        type: choice
        options:
          - production
          - staging
      overwrite_env:
        description: Overwrite remote $DEPLOY_PATH/.env even if it already exists
        required: false
        default: false
        type: boolean
  push:
    branches:
      - main
    tags:
      - 'v*'

permissions:
  contents: read
  packages: write

concurrency:
  group: deploy-${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  APP_NAME: anvilkit-auth-template

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: auth
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U postgres -d auth"
          --health-interval 5s
          --health-timeout 3s
          --health-retries 20
      redis:
        image: redis:7
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 5s
          --health-timeout 3s
          --health-retries 20
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Prepare Go workspace dependencies
        run: |
          go work sync
          for dir in modules/common-go services/auth-api services/admin-api; do
            (cd "$dir" && go mod download)
          done

      - name: Install PostgreSQL client
        run: sudo apt-get update && sudo apt-get install -y postgresql-client

      - name: Wait for Postgres readiness
        run: |
          for i in {1..30}; do
            if pg_isready -h localhost -p 5432 -U postgres -d auth; then
              exit 0
            fi
            sleep 2
          done
          echo "Postgres did not become ready in time" >&2
          exit 1

      - name: Migrate database
        run: |
          for file in $(find services/auth-api/migrations services/admin-api/migrations -maxdepth 1 -type f -name '*.sql' | sort); do
            psql "postgres://postgres:postgres@localhost:5432/auth?sslmode=disable" -v ON_ERROR_STOP=1 -f "$file"
          done

      - name: Run module tests
        env:
          DB_DSN: postgres://postgres:postgres@localhost:5432/auth?sslmode=disable
          REDIS_ADDR: localhost:6379
          TEST_DB_DSN: postgres://postgres:postgres@localhost:5432/auth?sslmode=disable
          TEST_REDIS_ADDR: localhost:6379
          JWT_SECRET: ci-secret
          JWT_ISSUER: http://ci.local
          JWT_AUDIENCE: ci-aud
          PASSWORD_MIN_LEN: 8
          BCRYPT_COST: 10
          LOGIN_FAIL_LIMIT: 5
          LOGIN_FAIL_WINDOW_MIN: 15
        run: |
          for dir in modules/common-go services/auth-api services/admin-api; do
            (cd "$dir" && go test ./... -count=1)
          done

      - name: Run workspace root tests
        env:
          DB_DSN: postgres://postgres:postgres@localhost:5432/auth?sslmode=disable
          REDIS_ADDR: localhost:6379
          TEST_DB_DSN: postgres://postgres:postgres@localhost:5432/auth?sslmode=disable
          TEST_REDIS_ADDR: localhost:6379
          JWT_SECRET: ci-secret
          JWT_ISSUER: http://ci.local
          JWT_AUDIENCE: ci-aud
          PASSWORD_MIN_LEN: 8
          BCRYPT_COST: 10
          LOGIN_FAIL_LIMIT: 5
          LOGIN_FAIL_WINDOW_MIN: 15
        run: go test ./... -count=1

  build:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta_auth.outputs.version }}
      image_owner: ${{ steps.prep.outputs.owner_lc }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Diagnostic trigger context
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF: ${{ github.ref }}
          REF_NAME: ${{ github.ref_name }}
          REF_TYPE: ${{ github.ref_type }}
          SHA: ${{ github.sha }}
          ACTOR: ${{ github.actor }}
          INPUTS_JSON: ${{ toJson(github.event.inputs) }}
        run: |
          echo "event_name=${EVENT_NAME}"
          echo "ref=${REF}"
          echo "ref_name=${REF_NAME}"
          echo "ref_type=${REF_TYPE}"
          echo "sha=${SHA}"
          echo "actor=${ACTOR}"
          echo "inputs=${INPUTS_JSON}"

      - name: Prepare image owner
        id: prep
        run: echo "owner_lc=${GITHUB_REPOSITORY_OWNER,,}" >> "$GITHUB_OUTPUT"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate auth-api metadata
        id: meta_auth
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ steps.prep.outputs.owner_lc }}/${{ env.APP_NAME }}-auth-api
          tags: |
            type=ref,event=tag
            type=sha,prefix=sha-

      - name: Validate production compose config
        env:
          IMAGE_OWNER: ${{ steps.prep.outputs.owner_lc }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          cp .env.example .env
          tmp_migrations_dir="$PWD/.ci/migrations"
          rm -rf "$tmp_migrations_dir"
          mkdir -p "$tmp_migrations_dir/auth-api" "$tmp_migrations_dir/admin-api"
          cp services/auth-api/migrations/*.sql "$tmp_migrations_dir/auth-api/"
          cp services/admin-api/migrations/*.sql "$tmp_migrations_dir/admin-api/"
          export MIGRATIONS_DIR="$tmp_migrations_dir"
          docker compose --project-directory . --env-file .env -f deploy/docker-compose.prod.yml config > /dev/null
          rm -rf "$tmp_migrations_dir"
          rm -f .env

      - name: Build and push auth-api image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: services/auth-api/Dockerfile
          push: true
          tags: ${{ steps.meta_auth.outputs.tags }}
          labels: ${{ steps.meta_auth.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Generate admin-api metadata
        id: meta_admin
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ steps.prep.outputs.owner_lc }}/${{ env.APP_NAME }}-admin-api
          tags: |
            type=ref,event=tag
            type=sha,prefix=sha-

      - name: Build and push admin-api image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: services/admin-api/Dockerfile
          push: true
          tags: ${{ steps.meta_admin.outputs.tags }}
          labels: ${{ steps.meta_admin.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    runs-on: ubuntu-latest
    needs: [test, build]
    if: needs.test.result == 'success'
    environment: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required deploy secrets
        env:
          DB_DSN: ${{ secrets.DB_DSN }}
          REDIS_ADDR: ${{ secrets.REDIS_ADDR }}
          JWT_ISSUER: ${{ secrets.JWT_ISSUER }}
          JWT_AUDIENCE: ${{ secrets.JWT_AUDIENCE }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          CORS_ALLOW_ORIGINS: ${{ secrets.CORS_ALLOW_ORIGINS }}
          DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          set -euo pipefail
          missing=()
          for name in DB_DSN REDIS_ADDR JWT_ISSUER JWT_AUDIENCE JWT_SECRET CORS_ALLOW_ORIGINS DEPLOY_SSH_KEY DEPLOY_HOST DEPLOY_USER DEPLOY_PATH; do
            if [[ -z "${!name:-}" ]]; then
              missing+=("$name")
            fi
          done

          if ((${#missing[@]} > 0)); then
            echo "::error::Missing required secrets for deploy environment: ${missing[*]}"
            echo "Please configure these secrets in GitHub Environment '${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}'."
            echo "Required app secrets: DB_DSN, REDIS_ADDR, JWT_ISSUER, JWT_AUDIENCE, JWT_SECRET, CORS_ALLOW_ORIGINS"
            echo "Required deploy secrets: DEPLOY_SSH_KEY, DEPLOY_HOST, DEPLOY_USER, DEPLOY_PATH (DEPLOY_PORT optional; defaults to 22)"
            exit 1
          fi

      - name: Configure SSH key
        run: |
          install -m 700 -d ~/.ssh
          printf '%s\n' '${{ secrets.DEPLOY_SSH_KEY }}' > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519

      - name: Prepare remote .env content
        env:
          DB_DSN: ${{ secrets.DB_DSN }}
          REDIS_ADDR: ${{ secrets.REDIS_ADDR }}
          JWT_ISSUER: ${{ secrets.JWT_ISSUER }}
          JWT_AUDIENCE: ${{ secrets.JWT_AUDIENCE }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          CORS_ALLOW_ORIGINS: ${{ secrets.CORS_ALLOW_ORIGINS }}
          ACCESS_TTL_MIN: ${{ secrets.ACCESS_TTL_MIN }}
          REFRESH_TTL_HOURS: ${{ secrets.REFRESH_TTL_HOURS }}
          CORS_ALLOW_CREDENTIALS: ${{ secrets.CORS_ALLOW_CREDENTIALS }}
          USE_INTERNAL_DEPS: ${{ vars.USE_INTERNAL_DEPS }}
        run: |
          set -euo pipefail
          : "${JWT_ISSUER:?missing required secret JWT_ISSUER}"
          : "${JWT_AUDIENCE:?missing required secret JWT_AUDIENCE}"
          : "${JWT_SECRET:?missing required secret JWT_SECRET}"
          : "${CORS_ALLOW_ORIGINS:?missing required secret CORS_ALLOW_ORIGINS}"

          deps="${USE_INTERNAL_DEPS:-true}"
          db_dsn="${DB_DSN:-postgres://postgres:postgres@pg:5432/auth?sslmode=disable}"
          redis_addr="${REDIS_ADDR:-redis:6379}"

          if [[ "$db_dsn" == *"@127.0.0.1:"* || "$db_dsn" == *"@localhost:"* ]]; then
            if [[ "$deps" == "true" ]]; then
              db_dsn="postgres://postgres:postgres@pg:5432/auth?sslmode=disable"
              echo "DB_DSN points to localhost/127.0.0.1; overriding to internal compose service host pg:5432."
            else
              echo "DB_DSN points to localhost/127.0.0.1, which is invalid for containerized deploy with USE_INTERNAL_DEPS=false." >&2
              echo "Set DB_DSN to a reachable external DB host/IP (not localhost)." >&2
              exit 1
            fi
          fi

          access_ttl="${ACCESS_TTL_MIN:-15}"
          refresh_ttl="${REFRESH_TTL_HOURS:-168}"
          cors_credentials="${CORS_ALLOW_CREDENTIALS:-false}"

          cat > .deploy.env <<EOF_ENV
          DB_DSN=${db_dsn}
          REDIS_ADDR=${redis_addr}
          JWT_ISSUER=${JWT_ISSUER}
          JWT_AUDIENCE=${JWT_AUDIENCE}
          JWT_SECRET=${JWT_SECRET}
          CORS_ALLOW_ORIGINS=${CORS_ALLOW_ORIGINS}
          ACCESS_TTL_MIN=${access_ttl}
          REFRESH_TTL_HOURS=${refresh_ttl}
          CORS_ALLOW_CREDENTIALS=${cors_credentials}
          EOF_ENV
          chmod 600 .deploy.env

      - name: Ensure remote .env exists (or overwrite)
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          OVERWRITE_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.overwrite_env || 'false' }}
        run: |
          set -euo pipefail
          port="${DEPLOY_PORT:-22}"

          ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
            "mkdir -p '$DEPLOY_PATH'"

          if [[ "${OVERWRITE_ENV}" == "true" ]]; then
            scp -P "$port" -o StrictHostKeyChecking=accept-new .deploy.env \
              "$DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH/.env"
            ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
              "chmod 600 '$DEPLOY_PATH/.env'"
          else
            if ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
              "test -f '$DEPLOY_PATH/.env'"; then
              echo "Remote .env already exists; keeping existing file."
            else
              scp -P "$port" -o StrictHostKeyChecking=accept-new .deploy.env \
                "$DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH/.env"
              ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
                "chmod 600 '$DEPLOY_PATH/.env'"
            fi
          fi

          ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
            "test -f '$DEPLOY_PATH/.env' && echo 'Verified env file path: $DEPLOY_PATH/.env'"

      - name: Upload deployment assets
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          set -euo pipefail
          port="${DEPLOY_PORT:-22}"
          ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
            "mkdir -p '$DEPLOY_PATH/deploy' '$DEPLOY_PATH/scripts'"

          # Reset migrations directory to keep deploy idempotent and avoid stale/legacy files
          # from previous releases causing count mismatches.
          ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
            "rm -rf '$DEPLOY_PATH/migrations' && mkdir -p '$DEPLOY_PATH/migrations/auth-api' '$DEPLOY_PATH/migrations/admin-api'"

          scp -P "$port" -o StrictHostKeyChecking=accept-new deploy/docker-compose.prod.yml \
            "$DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH/deploy/docker-compose.prod.yml"
          scp -P "$port" -o StrictHostKeyChecking=accept-new .env.example \
            "$DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH/.env.example"
          scp -P "$port" -o StrictHostKeyChecking=accept-new scripts/remote_deploy.sh \
            "$DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH/scripts/remote_deploy.sh"

          # Stream all migrations as tar archives and extract by service to avoid filename collisions.
          local_count=$(find services/auth-api/migrations services/admin-api/migrations -maxdepth 1 -type f -name '*.sql' | wc -l)
          tar -C services/auth-api/migrations -cf - $(ls -1 services/auth-api/migrations/*.sql | sort | xargs -n1 basename) \
            | ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
              "tar -C '$DEPLOY_PATH/migrations/auth-api' -xf -"
          tar -C services/admin-api/migrations -cf - $(ls -1 services/admin-api/migrations/*.sql | sort | xargs -n1 basename) \
            | ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
              "tar -C '$DEPLOY_PATH/migrations/admin-api' -xf -"

          # Verify remote count matches local count â€” no hardcoded filenames.
          remote_count=$(ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
            "find '$DEPLOY_PATH/migrations' -maxdepth 2 -type f -name '*.sql' | wc -l")
          if [[ "$remote_count" -ne "$local_count" ]]; then
            echo "::error::Migration file count mismatch: local=$local_count remote=$remote_count" >&2
            ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
              "ls -la '$DEPLOY_PATH/migrations'; ls -la '$DEPLOY_PATH/migrations/auth-api'; ls -la '$DEPLOY_PATH/migrations/admin-api'" >&2
            exit 1
          fi
          echo "Migrations uploaded: $remote_count file(s)"
          ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
            "ls -la '$DEPLOY_PATH/migrations'; ls -la '$DEPLOY_PATH/migrations/auth-api'; ls -la '$DEPLOY_PATH/migrations/admin-api'"

      - name: Run remote deployment
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          IMAGE_TAG: ${{ needs.build.outputs.image_tag }}
          IMAGE_OWNER: ${{ needs.build.outputs.image_owner }}
          USE_INTERNAL_DEPS: ${{ vars.USE_INTERNAL_DEPS }}
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          DB_DSN: ${{ secrets.DB_DSN }}
          REDIS_ADDR: ${{ secrets.REDIS_ADDR }}
          JWT_ISSUER: ${{ secrets.JWT_ISSUER }}
          JWT_AUDIENCE: ${{ secrets.JWT_AUDIENCE }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          CORS_ALLOW_ORIGINS: ${{ secrets.CORS_ALLOW_ORIGINS }}
          ACCESS_TTL_MIN: ${{ secrets.ACCESS_TTL_MIN }}
          REFRESH_TTL_HOURS: ${{ secrets.REFRESH_TTL_HOURS }}
          CORS_ALLOW_CREDENTIALS: ${{ secrets.CORS_ALLOW_CREDENTIALS }}
        run: |
          set -euo pipefail
          : "${GHCR_USERNAME:?missing required secret GHCR_USERNAME}"
          : "${GHCR_TOKEN:?missing required secret GHCR_TOKEN}"
          : "${JWT_ISSUER:?missing required secret JWT_ISSUER}"
          : "${JWT_AUDIENCE:?missing required secret JWT_AUDIENCE}"
          : "${JWT_SECRET:?missing required secret JWT_SECRET}"

          port="${DEPLOY_PORT:-22}"
          deps="${USE_INTERNAL_DEPS:-true}"
          ghcr_username_escaped=$(printf '%q' "$GHCR_USERNAME")
          ghcr_token_escaped=$(printf '%q' "$GHCR_TOKEN")
          db_dsn_escaped=$(printf '%q' "${DB_DSN:-}")
          redis_addr_escaped=$(printf '%q' "${REDIS_ADDR:-}")
          jwt_issuer_escaped=$(printf '%q' "$JWT_ISSUER")
          jwt_audience_escaped=$(printf '%q' "$JWT_AUDIENCE")
          jwt_secret_escaped=$(printf '%q' "$JWT_SECRET")
          cors_allow_origins_escaped=$(printf '%q' "${CORS_ALLOW_ORIGINS:-}")
          access_ttl_min_escaped=$(printf '%q' "${ACCESS_TTL_MIN:-}")
          refresh_ttl_hours_escaped=$(printf '%q' "${REFRESH_TTL_HOURS:-}")
          cors_allow_credentials_escaped=$(printf '%q' "${CORS_ALLOW_CREDENTIALS:-}")
          ssh -p "$port" -o StrictHostKeyChecking=accept-new "$DEPLOY_USER@$DEPLOY_HOST" \
            "chmod +x '$DEPLOY_PATH/scripts/remote_deploy.sh' && \
             GHCR_USERNAME=$ghcr_username_escaped GHCR_TOKEN=$ghcr_token_escaped \
             DB_DSN=$db_dsn_escaped REDIS_ADDR=$redis_addr_escaped \
             JWT_ISSUER=$jwt_issuer_escaped JWT_AUDIENCE=$jwt_audience_escaped JWT_SECRET=$jwt_secret_escaped \
             CORS_ALLOW_ORIGINS=$cors_allow_origins_escaped ACCESS_TTL_MIN=$access_ttl_min_escaped \
             REFRESH_TTL_HOURS=$refresh_ttl_hours_escaped CORS_ALLOW_CREDENTIALS=$cors_allow_credentials_escaped \
             '$DEPLOY_PATH/scripts/remote_deploy.sh' '$DEPLOY_PATH' '$IMAGE_TAG' '$IMAGE_OWNER' '$deps'"

      - name: Cleanup local deploy env artifact
        if: always()
        run: rm -f .deploy.env
